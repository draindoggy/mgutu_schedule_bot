import asyncio
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher
from aiogram.filters import Command, StateFilter
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
import aiohttp
import os
from dotenv import load_dotenv


load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
SCHEDULE_URL = 'https://dec.mgutm.ru/api/Rasp?idGroup=30948'

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher(storage=MemoryStorage())

class ScheduleStates(StatesGroup):
    select_subgroup = State()
    select_date = State()

async def get_schedule(date: datetime.date, subgroup: str) -> str:
    async with aiohttp.ClientSession() as session:
        async with session.get(SCHEDULE_URL) as response:
            if response.status != 200:
                return f"–æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è: —Å—Ç–∞—Ç—É—Å {response.status}"
            data = await response.json()

    if not data.get('data', {}).get('rasp'):
        return f"—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è {date.strftime('%d.%m.%Y')} –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."

    subgroup_text = f"{subgroup} –ø/–≥" if subgroup != "all" else "–≤—Å–µ –ø–æ–¥–≥—Ä—É–ø–ø—ã"
    day_of_week = ""
    schedule_text = f"—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {date.strftime('%d.%m.%Y')} ({subgroup_text})\n\n"
    found = False

    for lesson in data['data']['rasp']:
        lesson_date = lesson['–¥–∞—Ç–∞'][:10]
        if lesson_date == date.strftime('%Y-%m-%d'):
            if not day_of_week:
                day_of_week = lesson.get('–¥–µ–Ω—å_–Ω–µ–¥–µ–ª–∏', '–ù–µ —É–∫–∞–∑–∞–Ω').lower()
            if ("–ø/–≥" not in lesson['–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞'] or
                (subgroup == "all" and "–ø/–≥" in lesson['–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞']) or
                (subgroup != "all" and f"–ø/–≥ {subgroup}" in lesson['–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞'])):
                found = True

                room_raw = str(lesson.get('–∞—É–¥–∏—Ç–æ—Ä–∏—è', '–ù–µ —É–∫–∞–∑–∞–Ω–∞')).strip().capitalize()
                room = room_raw.split('-', 1)[1] if '-' in room_raw else room_raw

                schedule_text += (
                    f"üïì {lesson['–Ω–∞—á–∞–ª–æ']} - {lesson['–∫–æ–Ω–µ—Ü']}\n"
                    f"üìö {lesson['–¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞']}\n"
                    f"üë®‚Äçüè´ {lesson['—Ñ–∏–æ–ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è']}\n"
                    f"üè´ {room}\n\n"
                )

    if not found:
        return f"—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è {date.strftime('%d.%m.%Y')} ({subgroup_text}) –Ω–µ –Ω–∞–π–¥–µ–Ω–æ."

    schedule_text = (
        f"{day_of_week}\n\n"
        f"—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ {date.strftime('%d.%m.%Y')} ({subgroup_text})\n\n"
        + schedule_text.split('\n', 2)[2]
    )

    return schedule_text

def create_subgroup_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="–ø/–≥ 1", callback_data="subgroup_1"),
                InlineKeyboardButton(text="–ø/–≥ 2", callback_data="subgroup_2"),
                InlineKeyboardButton(text="–≤—Å–µ –ø–æ–¥–≥—Ä—É–ø–ø—ã", callback_data="subgroup_all"),
            ]
        ]
    )

def create_date_keyboard(current_date: datetime.date) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="–ø—Ä–µ–¥—ã–¥—É—â–∏–π –¥–µ–Ω—å",
                    callback_data=f"prev_{current_date.strftime('%Y-%m-%d')}",
                ),
                InlineKeyboardButton(
                    text="—Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å",
                    callback_data=f"next_{current_date.strftime('%Y-%m-%d')}",
                ),
            ]
        ]
    )

@dp.message(Command(commands=["start", "schedule"]))
async def start_handler(message: Message, state: FSMContext):
    data = await state.get_data()
    last_message_id = data.get("last_message_id")
    start_prompt_id = data.get("start_prompt_id")
    user_command_id = data.get("user_command_id")

    for msg_id in [last_message_id, start_prompt_id, user_command_id]:
        if msg_id:
            try:
                await bot.delete_message(chat_id=message.chat.id, message_id=msg_id)
            except Exception:
                pass

    await state.clear()
    await state.update_data(user_command_id=message.message_id)

    sent_message = await message.answer(
        "–ø—Ä–∏–≤–µ—Ç! –≤—ã–±–µ—Ä–∏ —Å–≤–æ—é –ø–æ–¥–≥—Ä—É–ø–ø—É:", reply_markup=create_subgroup_keyboard()
    )
    await state.update_data(start_prompt_id=sent_message.message_id)
    await state.set_state(ScheduleStates.select_subgroup)

@dp.callback_query(
    lambda c: c.data.startswith("subgroup_"), StateFilter(ScheduleStates.select_subgroup)
)
async def process_subgroup_callback(callback_query: CallbackQuery, state: FSMContext):
    subgroup = callback_query.data.split("_")[1]
    today = datetime.now().date()
    schedule = await get_schedule(today, subgroup)

    data = await state.get_data()
    user_command_id = data.get("user_command_id")
    start_prompt_id = data.get("start_prompt_id")
    last_message_id = data.get("last_message_id")

    for msg_id in [user_command_id, start_prompt_id, last_message_id]:
        if msg_id:
            try:
                await bot.delete_message(
                    chat_id=callback_query.message.chat.id, message_id=msg_id
                )
            except Exception:
                pass

    sent_message = await bot.send_message(
        chat_id=callback_query.message.chat.id,
        text=schedule,
        reply_markup=create_date_keyboard(today),
    )

    await state.update_data(
        current_date=today.strftime("%Y-%m-%d"),
        subgroup=subgroup,
        last_message_id=sent_message.message_id,
    )
    await state.set_state(ScheduleStates.select_date)
    await callback_query.answer()

@dp.callback_query(
    lambda c: c.data.startswith(("prev_", "next_")), StateFilter(ScheduleStates.select_date)
)
async def process_day_callback(callback_query: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    subgroup = data.get("subgroup", "all")
    action, date_str = callback_query.data.split("_", 1)
    current_date = datetime.strptime(date_str, "%Y-%m-%d").date()
    new_date = current_date - timedelta(days=1) if action == "prev" else current_date + timedelta(days=1)

    schedule = await get_schedule(new_date, subgroup)
    edited_message = await callback_query.message.edit_text(
        text=schedule, reply_markup=create_date_keyboard(new_date)
    )

    await state.update_data(
        current_date=new_date.strftime("%Y-%m-%d"),
        last_message_id=edited_message.message_id,
    )
    await callback_query.answer()

async def main():
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())